<!DOCTYPE html>
<html lang="zh">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="google-site-verification" content="TZE0rZyIqLl10trYu3BWBWa1Vmz6HFwhb2OcNEK4u-s">
     <link rel="shortcut icon" href="/img/favicon.ico">
    <title>
        xkaneiki&#39;s blog
    </title>
    <meta name="description" content="嘿，这是xkaneiki的博客。欢迎访问！">
    <meta name="keywords" content="Code,CTFer,Blog">
    <link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">
    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/css/style.css">
</head>
<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-home
 replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            linux_kernel_heap
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h1 id="linux-kernel-heap"><a href="#linux-kernel-heap" class="headerlink" title="linux kernel heap"></a>linux kernel heap</h1><h2 id="Buddy-System"><a href="#Buddy-System" class="headerlink" title="Buddy System"></a>Buddy System</h2><p>伙伴系统</p>
<p>采用二分法分配内存</p>
<p>分配的内存大小必须是2的整数次幂，2的指数（幂）就称为一个块的order。</p>
<p>块的大小单位为一个页的大小，比如一个页为4k的系统，order为0的堆块的大小就是(2^0)*4K。</p>
<p>分配连续的物理空间</p>
<p>memory zone </p>
<p>DMA and DMA32 zones, highmem zone and a Normal zone and other zones</p>
<p>vmalloc 的分配的空间在虚拟内存下时连续的，但是不一定要在物理内存下时连续的。</p>
<p>通过/proc/buddyinfo和/proc/pagetypeinfo查看分配的情况</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># cat /proc/buddyinfo</span></span><br><span class="line">Node 0, zone      DMA      0      0      0      1      2      1      1      0      1      1      3</span><br><span class="line">Node 0, zone    DMA32      0      5      3      6      7      8      8     10      7      3     14</span><br></pre></td></tr></table></figure>
<h3 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h3><p>首先有个大堆块</p>
<p>当分配时首先确定需要的块大小（确定需要那个oder的块）</p>
<p>如果当前的order有剩余的块则分配值，否则将order更大的块进行切分</p>
<p>Linux中通过get_free_pages实现</p>
<h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><p>当有块释放时，检查相邻的块（从同一个块中切分出来的），就将其合并成更大的order的块。</p>
<p>Linux中通过alloc_pages实现</p>
<h3 id="buddy-allocator"><a href="#buddy-allocator" class="headerlink" title="buddy allocator"></a>buddy allocator</h3><p>分配页的函数在”linux/gfp.h”中（gfp是get free page的意思），其中 gfp_mask是alloc_pages用来表示谁来请求这次的内存分配。比如GFP_KERNEL用来表示这个页框是在内核中使用的，GFP_USER表示在用户空间使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> alloc_pages(gfp_mask, order) \</span></span><br><span class="line">		alloc_pages_node(numa_node_id(), gfp_mask, order)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Allocate pages, preferring the node given as nid. When nid == NUMA_NO_NODE,</span></span><br><span class="line"><span class="comment"> * prefer the current CPU's closest node. Otherwise node must be valid and</span></span><br><span class="line"><span class="comment"> * online.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct page *<span class="title">alloc_pages_node</span><span class="params">(<span class="keyword">int</span> nid, <span class="keyword">gfp_t</span> gfp_mask,</span></span></span><br><span class="line"><span class="function"><span class="params">						<span class="keyword">unsigned</span> <span class="keyword">int</span> order)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment"> * Allocate pages, preferring the node given as nid. The node must be valid and</span></span></span><br><span class="line"><span class="function"><span class="comment"> * online. For more general interface, see alloc_pages_node().</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct page *</span></span><br><span class="line"><span class="function">__<span class="title">alloc_pages_node</span><span class="params">(<span class="keyword">int</span> nid, <span class="keyword">gfp_t</span> gfp_mask, <span class="keyword">unsigned</span> <span class="keyword">int</span> order)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment"> * This is the 'heart' of the zoned buddy allocator.</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function">struct page *</span></span><br><span class="line"><span class="function">__<span class="title">alloc_pages_nodemask</span><span class="params">(<span class="keyword">gfp_t</span> gfp_mask, <span class="keyword">unsigned</span> <span class="keyword">int</span> order, <span class="keyword">int</span> preferred_nid,</span></span></span><br><span class="line"><span class="function"><span class="params">							<span class="keyword">nodemask_t</span> *nodemask)</span></span></span><br></pre></td></tr></table></figure>
<p>释放页</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_pages</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> order)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (addr != <span class="number">0</span>) &#123;</span><br><span class="line">		VM_BUG_ON(!virt_addr_valid((<span class="keyword">void</span> *)addr));</span><br><span class="line">		__free_pages(virt_to_page((<span class="keyword">void</span> *)addr), order);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//---&gt;....</span></span><br></pre></td></tr></table></figure>
<h2 id="slab"><a href="#slab" class="headerlink" title="slab"></a>slab</h2><p><img src="/2021/03/24/linux-kernel-heap/slab.png" alt="img"></p>
<p>slabs_full    完全分配的slab</p>
<p>slabs_partital    部分分配的slab</p>
<p>slabs_empty    空空的slab</p>
<p>SLAB: 从伙伴系统分配的 2^order 个物理页就组成了一个 SLAB ，而后续的操作就是在这个 SLAB 上在进行细分的，具体的结构体是 struct slab 。</p>
<p>每个kmem_cache里面包含的很多slab结构，同一个kmem_cache中包含的obj的大小都是相同的，每个slab只针对一种数据类型</p>
<p>每个slab结构中可以包含很多的obj</p>
<p>每个slab是有一个或者多个连续的页组成</p>
<p>kmalloc是基于slab分配器的</p>
<p>利用cat /porc/slabinfo来打印出相关的结构</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Boot took 0.99 seconds</span><br><span class="line">/ <span class="comment"># cat /proc/slabinfo</span></span><br><span class="line">slabinfo - version: 2.1</span><br><span class="line"><span class="comment"># name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;limit&gt; &lt;batchcount&gt; &lt;sharedfactor&gt; : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; &lt;sharedavail&gt;</span></span><br><span class="line">kcopyd_job             0      0   3312    9    8 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">scsi_sense_cache      32     32    128   32    1 : tunables    0    0    0 : slabdata      1      1      0</span><br><span class="line">i915_vma               0      0    576   14    2 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">execute_cb             0      0    128   32    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">i915_request           0      0    640   12    2 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">sgpool-16              8      8    512    8    1 : tunables    0    0    0 : slabdata      1      1      0</span><br><span class="line">isofs_inode_cache      0      0    624   13    2 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">fat_inode_cache        0      0    712   11    2 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">fat_cache              0      0     40  102    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">jbd2_journal_handle      0      0     48   85    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">jbd2_journal_head      0      0    120   34    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">jbd2_revoke_table_s      0      0     16  256    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">ext4_inode_cache       0      0   1064   15    4 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">ext4_allocation_context      0      0    128   32    1 : tunables    0    0    0 : slabdata      0      0      0</span><br></pre></td></tr></table></figure>
<p>active_objs 正在被使用的obj的数量</p>
<p>num_objs obj的总量</p>
<p>objsize obj的大小</p>
<p> objperslab 每个slab中可以有多少个obj</p>
<p> pagesperslab 每个slab对应几个页·</p>
<h3 id="slab-allocator"><a href="#slab-allocator" class="headerlink" title="slab allocator"></a>slab allocator</h3><p>buddy系统会产生大量的内碎片，比如（伙伴系统只能分配连续的物理内存页）一个33page的请求就伙伴系统就会分配2^6=64pages，相当于浪费了31pages。引入slab allocator就是为了把页分成更小的块来进行分配。</p>
<p><strong>slab 核心思想是在保存那些常用堆块的缓存，以便能够在内核中进行分配。</strong>这是非常有意义的，通过缓存被释放obj，有一些常用的结构就能够在复制新的同样的结构时进行快速分配。通过重新利用被释放的obj，在某些情况下，内核就不必再重新申请内存了。Linux的slab allocator经过长期的发展，已经发生了很大的变化。现在slab allocator有三种不同的实现</p>
<ol>
<li>SLOB Allocator 是在solaris os被实现的最原始的slab allocator，现在大多被用在内存很小的嵌入式系统里，分配小内存非常高效，首次适应分配算法</li>
<li>SLAB Allocator SLAB的升级，旨在变得更加的“cache friendly”</li>
<li>SLUB Allocator 通过减少使用的队列/链来回获得比SLAB更好的执行时间</li>
</ol>
<p><strong>今天大多数系统中使用的SLUB</strong></p>
<p>一个slab cache包含许多slab，一个slab中包含很多obj</p>
<p>？分别对应什么结构</p>
<p>slab cahes —&gt;struct kmem_cache</p>
<p>页 —&gt; struct page</p>
<p>slab —&gt; page</p>
<p>obj的结构</p>
<p>有两种主要的cache</p>
<ol>
<li>Dedicate（专用的）：这些缓存是给那些常用的内核中的结构的。这写结构被分配时就是初始化过的，被释放的时候还是保持被初始化的，一边下一次分配的时候会变得更快</li>
<li>Generic（通用的）：这些都是通用的缓存，在大多数情况下，它们的大小对应于2的幂。</li>
</ol>
<p>dma-kmalloc-256  以上时专用缓存，dma-kmalloc-256及以下时通用缓存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vm_area_struct     65543  66082    208   19    1 : tunables    0    0    0 : slabdata   3478   3478      0</span><br><span class="line">mm_struct            213    225   2112   15    8 : tunables    0    0    0 : slabdata     15     15      0</span><br><span class="line">files_cache          228    230    704   23    4 : tunables    0    0    0 : slabdata     10     10      0</span><br><span class="line">signal_cache         399    448   1024   16    4 : tunables    0    0    0 : slabdata     28     28      0</span><br><span class="line">sighand_cache        414    435   2112   15    8 : tunables    0    0    0 : slabdata     29     29      0</span><br><span class="line">task_struct         1102   1125   5952    5    8 : tunables    0    0    0 : slabdata    225    225      0</span><br><span class="line">dma-kmalloc-256        0      0    256   16    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-128        0      0    128   32    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-64         0      0     64   64    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-32         0      0     32  128    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-16         0      0     16  256    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-8          0      0      8  512    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">kmalloc-256         1801   2064    256   16    1 : tunables    0    0    0 : slabdata    129    129      0</span><br><span class="line">kmalloc-192         4410   4410    192   21    1 : tunables    0    0    0 : slabdata    210    210      0</span><br><span class="line">kmalloc-128         2689   2752    128   32    1 : tunables    0    0    0 : slabdata     86     86      0</span><br><span class="line">kmalloc-96          6952   7350     96   42    1 : tunables    0    0    0 : slabdata    175    175      0</span><br><span class="line">kmalloc-64         25933  26496     64   64    1 : tunables    0    0    0 : slabdata    414    414      0</span><br><span class="line">kmalloc-32         15150  15616     32  128    1 : tunables    0    0    0 : slabdata    122    122      0</span><br><span class="line">kmalloc-16         18432  18432     16  256    1 : tunables    0    0    0 : slabdata     72     72      0</span><br><span class="line">kmalloc-8          10149  10240      8  512    1 : tunables    0    0    0 : slabdata     20     20      0</span><br></pre></td></tr></table></figure>
<h4 id="kmalloc"><a href="#kmalloc" class="headerlink" title="kmalloc"></a>kmalloc</h4><p><strong>kmalloc是内核通过slab allocator进行一般内存分配的接口</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// "include/linux/slab.h"</span></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">void</span> *<span class="title">kmalloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags)</span></span>;</span><br><span class="line"><span class="comment">//allocates memory through slab allocator.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">kzalloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags)</span></span>;</span><br><span class="line"><span class="comment">//allocates memory (and zeroes it out like calloc() in libc) through the slab allocator.</span></span><br><span class="line"><span class="comment">//和libc中的calloc相似</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> * __<span class="function">must_check <span class="title">krealloc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *, <span class="keyword">size_t</span>, <span class="keyword">gfp_t</span>)</span></span>;</span><br><span class="line"><span class="comment">//resize existing allocation.</span></span><br><span class="line"><span class="comment">//和libc中realloc相似</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kfree</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="comment">//frees memory previously allocated.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kzfree</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="专用缓存（Dedicated-Cache）的初始化"><a href="#专用缓存（Dedicated-Cache）的初始化" class="headerlink" title="专用缓存（Dedicated Cache）的初始化"></a>专用缓存（Dedicated Cache）的初始化</h4><p>以vm_area_struct的slab cache 为例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//"kernel/fork.c"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* slab cache for vm_area_struct structures */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">vm_area_cachep</span>;</span></span><br><span class="line"></span><br><span class="line">vm_area_cachep = KMEM_CACHE(vm_area_struct, SLAB_PANIC|SLAB_ACCOUNT);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> KMEM_CACHE() is a macro defined in "/include/linux/slab.h" which actually expands</span></span><br><span class="line"><span class="comment"> to a call to kmem_cache_create() which is the procedure to register a new slab</span></span><br><span class="line"><span class="comment"> cache and adds the new cache to the list of all slabs in the system.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> = <span class="title">kmem_cache_alloc</span>(<span class="title">vm_area_cachep</span>, <span class="title">GFP_KERNEL</span>);</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> kmem_cache_alloc() is the procedure to allocate the object from the dedicated</span></span><br><span class="line"><span class="comment"> cache memory. The allocation will be attempted first on a partially filled slab,</span></span><br><span class="line"><span class="comment"> then (if no partially filled slabs are available) in a free slab,</span></span><br><span class="line"><span class="comment"> and if no free slabs are found,</span></span><br><span class="line"><span class="comment"> it will try to allocate new page frames from the underlying buddy allocator.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> kmem_cache_free(vm_area_cachep, vma);</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  kmem_cache_free() is the procedure that frees the memory allocated to the vma object</span></span><br><span class="line"><span class="comment">  previously allocated. The (now free'd) slab,</span></span><br><span class="line"><span class="comment">  will be kept in order to be used for future allocations and the memory is NOT</span></span><br><span class="line"><span class="comment">  released immediately after this call. When all of the slabs have been free'd,</span></span><br><span class="line"><span class="comment">  kernel modules have to call kmem_cache_destroy() to release the pre allocated memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h4 id="SLAB-Cache-管理"><a href="#SLAB-Cache-管理" class="headerlink" title="SLAB Cache 管理"></a>SLAB Cache 管理</h4><p>kmem_cache中的结构</p>
<p><code>unsigned int gfporder</code></p>
<p>每个slab能够存放的页的数量。</p>
<p><code>struct kmem_cache_node *node[MAN_NUMNODES]</code> </p>
<p>用来存储不同状态的slab，主要维护三个变量，这个主要是维护这个kmem_cache_node中的slab的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The slab lists for all objects.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> &#123;</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> list_lock;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLAB</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_partial</span>;</span>	<span class="comment">/* partial list first, better asm code */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_full</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_free</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> total_slabs;	<span class="comment">/* length of all slab lists */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> free_slabs;	<span class="comment">/* length of free slab list only */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> free_objects;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> free_limit;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> colour_next;	<span class="comment">/* Per-node cache coloring */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> *<span class="title">shared</span>;</span>	<span class="comment">/* shared per node */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">alien_cache</span> **<span class="title">alien</span>;</span>	<span class="comment">/* on other nodes */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> next_reap;	<span class="comment">/* updated without locking */</span></span><br><span class="line">	<span class="keyword">int</span> free_touched;		<span class="comment">/* updated without locking */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLUB</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> nr_partial;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">partial</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLUB_DEBUG</span></span><br><span class="line">	<span class="keyword">atomic_long_t</span> nr_slabs;</span><br><span class="line">	<span class="keyword">atomic_long_t</span> total_objects;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">full</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>struct array_cache __percpu *cpu_cache</code></p>
<p>这个结构是管理被释放的obj的块，entry中的每一项指向被释放的对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * struct array_cache</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Purpose:</span></span><br><span class="line"><span class="comment"> * - LIFO ordering, to hand out cache-warm objects from _alloc</span></span><br><span class="line"><span class="comment"> * - reduce the number of linked list operations</span></span><br><span class="line"><span class="comment"> * - reduce spinlock operations</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The limit is stored in the per-cpu structure to reduce the data cache</span></span><br><span class="line"><span class="comment"> * footprint.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> avail;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> limit;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> batchcount;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> touched;</span><br><span class="line">	<span class="keyword">void</span> *entry[];	<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Must have this definition in here for the proper</span></span><br><span class="line"><span class="comment">			 * alignment of array_cache. Also simplifies accessing</span></span><br><span class="line"><span class="comment">			 * the entries.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>page中的void <em>s_mem指向slab中的第一个obj;void </em>freelist;指向第一个free的obj</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* slab, slob and slub */</span></span><br><span class="line">			<span class="keyword">union</span> &#123;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* Partial pages */</span></span><br><span class="line">					<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">					<span class="keyword">int</span> pages;	<span class="comment">/* Nr of pages left */</span></span><br><span class="line">					<span class="keyword">int</span> pobjects;	<span class="comment">/* Approximate count */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">					<span class="keyword">short</span> <span class="keyword">int</span> pages;</span><br><span class="line">					<span class="keyword">short</span> <span class="keyword">int</span> pobjects;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span> <span class="comment">/* not slob */</span></span><br><span class="line">			<span class="comment">/* Double-word boundary */</span></span><br><span class="line">			<span class="keyword">void</span> *freelist;		<span class="comment">/* first free object */</span></span><br><span class="line">			<span class="keyword">union</span> &#123;</span><br><span class="line">				<span class="keyword">void</span> *s_mem;	<span class="comment">/* slab: first object */</span></span><br><span class="line">				<span class="keyword">unsigned</span> <span class="keyword">long</span> counters;		<span class="comment">/* SLUB */</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> &#123;</span>			<span class="comment">/* SLUB */</span></span><br><span class="line">					<span class="keyword">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line">					<span class="keyword">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line">					<span class="keyword">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="SLUB"><a href="#SLUB" class="headerlink" title="SLUB"></a>SLUB</h4><p>用来管理被释放的obj</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> &#123;</span></span><br><span class="line">	<span class="keyword">void</span> **freelist;	<span class="comment">/* Pointer to next available object */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> tid;	<span class="comment">/* Globally unique transaction id */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span>	<span class="comment">/* The slab from which we are allocating */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">partial</span>;</span>	<span class="comment">/* Partially allocated frozen slabs */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLUB_STATS</span></span><br><span class="line">	<span class="keyword">unsigned</span> stat[NR_SLUB_STAT_ITEMS];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

    </div>

    
</div>
    <div class="footer" id="footer">
    <p></p><h4>Copyright © 2020 | Author: xkaneiki | Theme By <a class="theme-author" href="https://github.com/Xunzhuo/hexo-theme-coder" style="font-size:14px; color: #969696">Coder</a></h4>
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <span id="busuanzi_container_site_pv">Page Views: <span id="busuanzi_value_site_pv"></span></span>
        <span class="post-meta-divider">|</span>
        <span id="busuanzi_container_site_uv">Unique Visitors: <span id="busuanzi_value_site_uv"></span></span>
    
    <label class="el-switch el-switch-blue el-switch-sm" style="vertical-align: sub;">
        <input type="checkbox" name="switch" id="update_style">
        <span class="el-switch-style"></span>
    </label>

    <!--         <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
    document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script> -->
<p></p>
</div>

<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="NOsswOncKgc8HOxqo9oxIWlX-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="z1FihjWEbS8uIfUQdmCtK7zz">
<script src="/libs/jquery.min.js"></script>
<script src="/libs/highlight/highlight.pack.js"></script>
<script src="//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script>
<script src="/js/js.js"></script>
<style type="text/css">
.v * {
color: #698fca;
}
.v .vlist .vcard .vhead .vsys {
color: #3a3e4a;
}
.v .vlist .vcard .vh .vmeta .vat {
color: #638fd5;
}
.v .vlist .vcard .vhead .vnick {
color: #6ba1ff;
}
.v a {
color: #8696b1;
}
.v .vlist .vcard .vhead .vnick:hover {
color: #669bfc;
}
</style>
    <script type="text/javascript" color="173,174,173" opacity='1' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
